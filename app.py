import streamlit as st
import pandas as pd
import base64
import json

from dotenv import dotenv_values
from openai import OpenAI
import instructor
from pydantic import BaseModel

from langfuse import Langfuse
import os
from dotenv import load_dotenv

load_dotenv()

langfuse = Langfuse()
api_key = os.getenv("OPENAI_API_KEY")

if not api_key:
    raise ValueError("Brakuje klucza OPENAI_API_KEY w ≈õrodowisku!")

llm_client = OpenAI(api_key=api_key)


def configure_clients():
    return langfuse  # ju≈º nie potrzebujesz instructor_client
# ---------------------------------------
# MODELE I FUNKCJE POMOCNICZE
# ---------------------------------------

class ParseInputResponse(BaseModel):
    Imiƒô: str
    Nazwisko: str
    Miasto: str
    Dru≈ºyna: str
    Wiek: int
    P≈Çeƒá: str
    Czas: int  # czas w sekundach
    Dystans: float  # dystans w kilometrach



def parse_input_with_gpt(user_text: str, langfuse_client) -> dict:
    """Wywo≈Çuje GPT i ≈õledzi z Langfuse ca≈Çy proces parsowania."""
    system_prompt = (
       "Jeste≈õ asystentem, kt√≥ry otrzymuje swobodnie napisany tekst u≈ºytkownika i ma za zadanie wyodrƒôbniƒá dane:\n"
        "\n"
        "1) WyciƒÖgnij dystans pokonany przez u≈ºytkownika jako liczbƒô w kilometrach (float).\n"
        "   - Akceptowane formaty: ‚Äû10 km‚Äù, ‚Äû5 kilometr√≥w‚Äù, ‚Äû5000 metr√≥w‚Äù itp.\n"
        "   - Zamie≈Ñ wszystko na kilometry (np. 5000 metr√≥w ‚Üí 5.0). Je≈õli nie podano, ustaw 0.0.\n"
        "\n"
        "2) WyciƒÖgnij czas jako liczbƒô sekund (int).\n"
        "   - Akceptowane formaty: ‚Äû45 minut‚Äù, ‚Äû1h 30min‚Äù, ‚Äû01:35:00‚Äù, ‚Äû3600s‚Äù itp.\n"
        "   - Zamie≈Ñ wszystko na liczbƒô sekund (np. 45 minut ‚Üí 2700). Je≈õli nie podano, ustaw 0.\n"
        "\n"
        "Nie obliczaj czasu p√≥≈Çmaratonu (`Czas_sec`) ‚Äì to zrobi kod.\n"
        "\n"
        "3) Dodatkowe dane:\n"
        "   - Wiek: je≈õli brak ‚Üí 0,\n"
        "   - P≈Çeƒá: M lub K. Domy≈õlnie przyjmij M, ale je≈õli imiƒô lub tekst wskazuje wyra≈∫nie na kobietƒô (np. Janina), wybierz K. Spr√≥buj rozpoznaƒá p≈Çeƒá na podstawie imienia i kontekstu, nawet je≈õli nie zosta≈Ça jawnie podana.\n"
        "   - Imiƒô: je≈õli brak ‚Üí \"Anonimowe\",\n"
        "   - Nazwisko: je≈õli brak ‚Üí \"Anonimowe\",\n"
        "   - Miasto: je≈õli brak ‚Üí \"Nie podano\",\n"
        "   - Dru≈ºyna: je≈õli brak ‚Üí \"Brak dru≈ºyny\".\n"
        "\n"
        "Zwr√≥ƒá WY≈ÅƒÑCZNIE obiekt JSON w formacie:\n"
        "{\"Wiek\":..., \"P≈Çeƒá\":\"...\", \"Imiƒô\":\"...\", \"Nazwisko\":\"...\", \"Miasto\":\"...\", \"Dru≈ºyna\":\"...\", \"Czas\":..., \"Dystans\":...}\n"
        "\n"
        "Bez komentarzy, bez dodatkowych p√≥l, bez t≈Çumaczenia. Tylko czysty JSON."
    )

    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_text},
    ]

    # Langfuse trace
    trace = langfuse_client.trace(name="parse_user_input", input=messages)
    span = trace.span(name="gpt-call", input={"user_text": user_text})

    try:
        completion = llm_client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            response_format={"type": "json_object"}
        )

        response = completion.choices[0].message.content

        span.end(
            output=response,
            usage={
                "input": completion.usage.prompt_tokens,
                "output": completion.usage.completion_tokens,
                "total": completion.usage.total_tokens,
                "unit": "TOKENS"
            }
        )

        trace.update(output=response)

        return json.loads(response)
    except Exception as e:
        span.end(output={"error": str(e)})
        trace.update(output={"error": str(e)})
        return {"error": f"Langfuse GPT error: {str(e)}"}

def seconds_to_hhmmss(seconds: float) -> str:
    """Konwersja sekund do formatu hh:mm:ss (z zerami wiodƒÖcymi)."""
    total_sec = int(round(seconds))
    h = total_sec // 3600
    m = (total_sec % 3600) // 60
    s = total_sec % 60
    return f"{h:02d}:{m:02d}:{s:02d}"

def load_data() -> pd.DataFrame:
    """Wczytuje dane z CSV, przetwarza kolumny i zwraca DataFrame."""
    df = pd.read_csv("df_2024_final.csv")
    df["Miejsce"] = df["Miejsce"].astype(int)
    df["km/h"] = df["km/h"].round(2)
    return df

def process_ranking(final_time_sec, final_gender, final_city, final_team, final_name1, final_name2, final_age, df_rank) -> dict:
    user_category = f"{final_gender}{str(final_age)[0]}0"
    best_time_sec = df_rank["Czas_sec"].min()

    # Obliczenie tempa
    user_speed = round(21.0975 / (final_time_sec / 3600), 2)
    best_speed = round(21.0975 / (best_time_sec / 3600), 2)
    time_diff = best_time_sec - final_time_sec

    # Dodajemy nowy wiersz u≈ºytkownika
    user_row = {
        "Imiƒô": final_name1,
        "Nazwisko": final_name2,
        "Miasto": final_city,
        "P≈Çeƒá": final_gender,
        "Wiek": final_age,
        "Dru≈ºyna": final_team,
        "Kategoria wiekowa": user_category,
        "Czas_sec": final_time_sec,
        "Czas": seconds_to_hhmmss(final_time_sec),
        "km/h": user_speed
    }

    df_rank_with_user = pd.concat([df_rank, pd.DataFrame([user_row])], ignore_index=True)

    # Sortowanie po czasie
    df_sorted = df_rank_with_user.sort_values("Czas_sec").reset_index(drop=True)
    df_sorted["Miejsce"] = df_sorted.index + 1

    # Znalezienie indeksu u≈ºytkownika
    user_index = df_sorted[
        (df_sorted["Imiƒô"] == final_name1) &
        (df_sorted["Nazwisko"] == final_name2) &
        (df_sorted["Czas_sec"] == final_time_sec)
    ].index[0]
    user_place = int(df_sorted.loc[user_index, "Miejsce"])

    return {
        "df_rank_sorted": df_sorted,
        "user_place": user_place,
        "user_index": user_index,
        "user_speed": user_speed,
        "best_speed": best_speed,
        "best_time_sec": best_time_sec,
        "time_diff": time_diff,
    }


def highlight_user(row, user_place):
    """Funkcja stylizujƒÖca wiersz u≈ºytkownika w tabeli."""
    if row["Miejsce"] == user_place:
        return ['background-color: rgba(255, 215, 0, 0.3)'] * len(row)
    return [''] * len(row)

def highlight_user(row, user_place):
    if row["Miejsce"] == user_place:
        return ['background-color: rgba(255, 215, 0, 0.3)'] * len(row)
    return [''] * len(row)

def display_ranking(df_rank_sorted, user_index, user_place):
    st.markdown("<h3 style='text-align: left;'>üèÜ TOP RANKING</h3>", unsafe_allow_html=True)

    ranking_cols = [
        "Miejsce", "Czas", "km/h", "Imiƒô", "Nazwisko",
        "Miasto", "P≈Çeƒá", "Wiek", "Dru≈ºyna", "Kategoria wiekowa"
    ]

    # Top tabela
    if user_place <= 10:
        top_n = df_rank_sorted.head(10)[ranking_cols]
    else:
        top_n = df_rank_sorted.head(5)[ranking_cols]

    st.dataframe(
        top_n.style.hide(axis="index")
            .format({"km/h": "{:.2f}"})
            .apply(lambda row: highlight_user(row, user_place), axis=1)
    )

    if user_place > 10:
        st.markdown("<h4 style='text-align: left;'>üìä Twoja pozycja w rankingu</h4>", unsafe_allow_html=True)
        lower = max(user_index - 5, 0)
        upper = min(user_index + 5, len(df_rank_sorted) - 1)
        nearby = df_rank_sorted.iloc[lower:upper + 1][ranking_cols]

        st.dataframe(
            nearby.style.hide(axis="index")
                .format({"km/h": "{:.2f}"})
                .apply(lambda row: highlight_user(row, user_place), axis=1)
        )







# ---------------------------------------
# G≈Å√ìWNA FUNKCJA APLIKACJI
# ---------------------------------------

def main():
    langfuse_client = configure_clients()
    df_rank = load_data()

    # --- NAG≈Å√ìWEK ---
    st.markdown(
        """
        <h2 style="color:#333; text-align:center; font-weight:300;">
            <span style="color:#28a745; font-weight:500;">Jan Ku≈õtyka</span> spojrzy na Tw√≥j czas...
            <br>... i powie Ci, co czeka Ciƒô na kolejnym <strong style="color:#FF5733;">p√≥≈Çmaratonie we Wroc≈Çawiu</strong>.
        </h2>
        """,
        unsafe_allow_html=True
    )

    # --- OPIS ---
    st.markdown(
        """
        <p style="font-size:1rem; color:#555; text-align:center; line-height:1.6;">
            Opowiedz o sobie ‚Äì jak przy zapisach na bieg.<br>
            <strong>Imiƒô. Nazwisko. Miasto. Dru≈ºyna. Wiek. P≈Çeƒá. Ostatni wynik i na jakim dystansie.</strong><br>
            W dowolnym formacie. Pisz swobodnie ‚Äì my to ogarniemy.
        </p>
        """,
        unsafe_allow_html=True
    )

    # --- INPUT ---
    st.markdown("<h4>üìù <strong>WPISZ SWOJE DANE:</strong></h4>", unsafe_allow_html=True)
    user_input = st.text_input("Wpisz swoje dane", label_visibility="collapsed")    



    # --- PRZYCISK ---
    if st.button("Oblicz ranking"):
        user_text = user_input.strip()
        if not user_text:
            st.warning("Nic nie wpisa≈Çe≈õ!")
        else:
            gpt_result = parse_input_with_gpt(user_text, langfuse_client)


            czas_w_sekundach = float(gpt_result.get("Czas", 0))
            dystans_w_km = float(gpt_result.get("Dystans", 0))

            if czas_w_sekundach > 0 and dystans_w_km > 0:
                tempo_sec_per_km = czas_w_sekundach / dystans_w_km
                czas_na_polmaraton = tempo_sec_per_km * 21.0975
                gpt_result["Czas_sec"] = int(czas_na_polmaraton)
            else:
                gpt_result["Czas_sec"] = 0

            final_time_sec = gpt_result["Czas_sec"]

            # with st.expander("üîç Co GPT wyciƒÖgnƒÖ≈Ç z Twoich danych?"):
                # st.json(gpt_result)
            
            if gpt_result["Czas_sec"] < 1800:
                st.warning("‚ö†Ô∏è Szybko biegasz, ale niestety Super-Bohaterowie jak Ty nie mogƒÖ startowaƒá w tym maratonie. ")

            final_age = gpt_result["Wiek"]
            final_gender = gpt_result["P≈Çeƒá"]
            final_time_sec = gpt_result["Czas_sec"]
            final_city = gpt_result.get("Miasto", "Nie podano")
            final_team = gpt_result.get("Dru≈ºyna", "Brak dru≈ºyny")
            final_name1 = gpt_result.get("Imiƒô", "Anonimowe")
            final_name2 = gpt_result.get("Nazwisko", "Anonimowe")

            # UPPERCASE
            final_name1 = final_name1.upper()
            final_name2 = final_name2.upper()
            final_city = final_city.upper()

            if final_time_sec <= 0:
                st.info("PrzeciƒÖ≈ºenie serwer√≥w, spr√≥buj jeszcze raz.")
            else:
                result = process_ranking(
                    final_time_sec, final_gender, final_city, final_team,
                    final_name1, final_name2, final_age, df_rank
                )
                if "error" in result:
                    st.error(result["error"])
                else:
                    user_place = result["user_place"]
                    user_index = result["user_index"]
                    user_speed = result["user_speed"]
                    best_speed = result["best_speed"]
                    best_time_sec = result["best_time_sec"]
                    time_diff = result["time_diff"]
                    df_rank_sorted = result["df_rank_sorted"]

                    # --- SEKCJA WYNIKU ---
                    st.markdown("<hr style='margin-top:30px; margin-bottom:20px;'>", unsafe_allow_html=True)
                    st.markdown(f"### Tw√≥j czas w p√≥≈Ç-maratonie to **{seconds_to_hhmmss(final_time_sec)}**")
                    st.markdown(f"## üèÖ **Miejsce: {user_place}**")

                    if user_place == 1:
                        st.markdown("## üéâ **GRATULUJƒò ZWYCIƒòSTWA!** üéâ")
                        st.markdown(f"### Twoje tempo: **{user_speed} km/h**")
                    else:
                        formatted_time_diff = seconds_to_hhmmss(abs(time_diff))
                        st.markdown(f"#### Aby wygraƒá, musisz pobiec **o {formatted_time_diff} szybciej**.")
                        st.markdown(
                            f"üìà **Wystarczy, ≈ºe zwiƒôkszysz tempo z {user_speed} km/h do {round(best_speed + 0.01, 2)} km/h!**"
                        )

                    display_ranking(df_rank_sorted, user_index, user_place)

    

    # --- MAPA ---
    st.markdown("<hr style='margin-top:40px;'>", unsafe_allow_html=True)
    st.markdown("### üó∫Ô∏è Trasa p√≥≈Çmaratonu we Wroc≈Çawiu", unsafe_allow_html=True)

    # WSTAW GRAFIKƒò MAPY (je≈õli masz mapƒô jako plik PNG / JPG)
    try:
        st.image("mapa.png", use_container_width=True)
    except:
        st.info("Mapa trasy nie zosta≈Ça jeszcze dodana.")

if __name__ == "__main__":
    main()